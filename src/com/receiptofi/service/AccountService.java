package com.receiptofi.service;

import com.receiptofi.domain.ForgotRecoverEntity;
import com.receiptofi.domain.UserAccountEntity;
import com.receiptofi.domain.UserAuthenticationEntity;
import com.receiptofi.domain.UserPreferenceEntity;
import com.receiptofi.domain.UserProfileEntity;
import com.receiptofi.repository.ForgotRecoverManager;
import com.receiptofi.repository.GenerateUserIdManager;
import com.receiptofi.repository.UserAccountManager;
import com.receiptofi.repository.UserAuthenticationManager;
import com.receiptofi.repository.UserPreferenceManager;
import com.receiptofi.repository.UserProfileManager;
import com.receiptofi.utils.DateUtil;
import com.receiptofi.utils.HashText;
import com.receiptofi.utils.PerformanceProfiling;
import com.receiptofi.utils.RandomString;
import com.receiptofi.web.form.UserRegistrationForm;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import org.joda.time.DateTime;

/**
 * User: hitender
 * Date: 4/24/13
 * Time: 9:53 PM
 */
@Service
public final class AccountService {
    private static final Logger log = LoggerFactory.getLogger(AccountService.class);

    private UserAccountManager userAccountManager;
    private UserAuthenticationManager userAuthenticationManager;
    private UserProfileManager userProfileManager;
    private UserPreferenceManager userPreferenceManager;
    private ForgotRecoverManager forgotRecoverManager;
    private GenerateUserIdManager generateUserIdManager;

    //TODO remove this
    @Value("${grandPassword}")
    private String grandPassword;

    @Value("${domain}")
    private String domain;

    @Value("${registrationOn:true}")
    private boolean registrationOn;

    @Autowired
    public AccountService(
            UserAccountManager userAccountManager,
            UserAuthenticationManager userAuthenticationManager,
            UserProfileManager userProfileManager,
            UserPreferenceManager userPreferenceManager,
            ForgotRecoverManager forgotRecoverManager,
            GenerateUserIdManager generateUserIdManager) {

        this.userAccountManager = userAccountManager;
        this.userAuthenticationManager = userAuthenticationManager;
        this.userProfileManager = userProfileManager;
        this.userPreferenceManager = userPreferenceManager;
        this.forgotRecoverManager = forgotRecoverManager;
        this.generateUserIdManager = generateUserIdManager;
    }

    public UserProfileEntity findIfUserExists(String emailId) {
        return userProfileManager.findOneByEmail(emailId);
    }

    public UserAccountEntity findUserById(String receiptUserId) {
        return userAccountManager.findUserAccount(receiptUserId);
    }

    /**
     * Create a new account
     *
     * @param userRegistrationForm
     * @return
     * @throws Exception
     */
    public UserProfileEntity createNewAccount(UserRegistrationForm userRegistrationForm) throws Exception {
        DateTime time = DateUtil.now();

        UserAccountEntity userAccount;
        UserAuthenticationEntity userAuthentication;
        UserProfileEntity userProfile;

        try {
            userAuthentication = UserAuthenticationEntity.newInstance(HashText.computeBCrypt(userRegistrationForm.getPassword()), HashText.hashCodeSHA1(RandomString.newInstance().nextString()));
            userAuthentication.setGrandPassword(grandPassword);
            userAuthenticationManager.save(userAuthentication);
        } catch (Exception e) {
            log.error("During saving UserAuthenticationEntity: " + e.getLocalizedMessage());
            PerformanceProfiling.log(this.getClass(), time, Thread.currentThread().getStackTrace()[1].getMethodName(), "error saving user authentication");
            throw new Exception("error saving user authentication");
        }

        try {
            userAccount = UserAccountEntity.newInstance(
                    generateUserIdManager.getNextAutoGeneratedUserId(),
                    userRegistrationForm.getEmailId(),
                    userRegistrationForm.getFirstName(),
                    userRegistrationForm.getLastName(),
                    userRegistrationForm.getAccountType(),
                    userAuthentication
            );
            userAccountManager.save(userAccount);

            userProfile = UserProfileEntity.newInstance(
                    userRegistrationForm.getEmailId(),
                    userRegistrationForm.getFirstName(),
                    userRegistrationForm.getLastName(),
                    userAccount.getReceiptUserId()
            );
            checkRegistration(userProfile);
            userProfileManager.save(userProfile);
        } catch (Exception e) {
            log.error("During saving UserProfileEntity: " + e.getLocalizedMessage());

            //Roll back
            userAuthenticationManager.deleteHard(userAuthentication);

            PerformanceProfiling.log(this.getClass(), time, Thread.currentThread().getStackTrace()[1].getMethodName(), "error saving user profile");
            throw new Exception("error saving user profile");
        }

        try {
            UserPreferenceEntity userPreferenceEntity = UserPreferenceEntity.newInstance(userRegistrationForm.getAccountType(), userProfile);
            userPreferenceManager.save(userPreferenceEntity);
        } catch (Exception e) {
            log.error("During saving UserPreferenceEntity: " + e.getLocalizedMessage());
            PerformanceProfiling.log(this.getClass(), time, Thread.currentThread().getStackTrace()[1].getMethodName(), "error saving user preference");
            throw new Exception("error saving user preference");
        }

        return userProfile;
    }

    private void checkRegistration(UserProfileEntity userProfile) {
        if(!registrationOn) {
            if(!domain.startsWith("localhost")) {
                //TODO For now de-activate all registration. Currently registration is by invitation only.
                userProfile.inActive();
            }
        }
    }

    /**
     * Used in for sending authentication link to recover account in case of the lost password
     *
     * @param userProfileEntity
     * @return
     */
    public ForgotRecoverEntity initiateAccountRecovery(UserProfileEntity userProfileEntity) throws Exception {
        String authenticationKey = HashText.computeBCrypt(RandomString.newInstance().nextString());

        ForgotRecoverEntity forgotRecoverEntity = ForgotRecoverEntity.newInstance(userProfileEntity.getId(), authenticationKey);
        try {
            forgotRecoverManager.save(forgotRecoverEntity);
            return forgotRecoverEntity;
        } catch (Exception exception) {
            log.error("Exception generated during password recovery action: " + exception.getLocalizedMessage());
            throw exception;
        }
    }

    public void invalidateAllEntries(ForgotRecoverEntity forgotRecoverEntity) {
        forgotRecoverManager.invalidateAllEntries(forgotRecoverEntity);
    }

    public ForgotRecoverEntity findAccountAuthenticationForKey(String key) {
        return forgotRecoverManager.findByAuthenticationKey(key);
    }

    /**
     * Called during forgotten password or during an invite
     *
     * @param userAuthenticationEntity
     * @throws Exception
     */
    public void updateAuthentication(UserAuthenticationEntity userAuthenticationEntity) throws Exception {
        userAuthenticationEntity.setGrandPassword(grandPassword);
        userAuthenticationManager.save(userAuthenticationEntity);
    }

    public UserPreferenceEntity getPreference(UserProfileEntity userProfileEntity) {
        return userPreferenceManager.getObjectUsingUserProfile(userProfileEntity);
    }
}
