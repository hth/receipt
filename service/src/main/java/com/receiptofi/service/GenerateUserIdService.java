package com.receiptofi.service;

import com.receiptofi.domain.GenerateUserIds;
import com.receiptofi.domain.UserAccountEntity;
import com.receiptofi.repository.GenerateUserIdManager;
import com.receiptofi.repository.UserAccountManager;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * User: hitender
 * Date: 6/5/16 1:10 PM
 */
@Service
public class GenerateUserIdService {
    private static final Logger LOG = LoggerFactory.getLogger(GenerateUserIdService.class);

    private int limit;
    private GenerateUserIdManager generateUserIdManager;
    private UserAccountManager userAccountManager;

    private final ConcurrentLinkedQueue<Long> dequeRids;

    @Autowired
    public GenerateUserIdService(
            /**
             * This limit is based on number of signup between server restarts.
             * In future this number would have to be adjusted.
             */
            @Value ("${limit:500}")
            int limit,

            GenerateUserIdManager generateUserIdManager,
            UserAccountManager userAccountManager) {
        this.limit = limit;
        this.generateUserIdManager = generateUserIdManager;
        this.userAccountManager = userAccountManager;

        /** Auto correct when some RIDs are skipped. */
        dequeRids = new ConcurrentLinkedQueue<>(findSkippedRids());
        LOG.info("Size of skipped rids={} ids={}", dequeRids.size(), dequeRids);
    }

    public String getNextAutoGeneratedUserId() {
        String rid;
        if (dequeRids.isEmpty()) {
            rid = generateUserIdManager.getNextAutoGeneratedUserId();
            LOG.info("Generated new rid={}", rid);
        } else {
            rid = String.valueOf(dequeRids.poll());
            LOG.info("Retrieved skipped rid={}", rid);
        }

        return rid;
    }

    /**
     * Find all the RID's that have been skipped because of some issue. This can happen.
     * Note: The code is not adaptive. Should find skipped RID's. But this code finds it
     * when server re-starts.
     *
     * @return
     */
    private Set<Long> findSkippedRids() {
        GenerateUserIds generateUserIds = generateUserIdManager.getLastGenerateUserId();

        List<UserAccountEntity> userAccounts = userAccountManager.getLastSoManyRecords(limit);
        Set<Long> userAccountWithIds = new HashSet<>();
        for (UserAccountEntity userAccount : userAccounts) {
            userAccountWithIds.add(Long.parseLong(userAccount.getReceiptUserId()));
        }

        Set<Long> skippedRids = new HashSet<>();
        if (generateUserIds != null) {
            long start = generateUserIds.getAutoGeneratedReceiptUserId() - limit;
            if (start < GenerateUserIds.STARTING_USER_ID) {
                start = GenerateUserIds.STARTING_USER_ID;
            }

            while (start <= generateUserIds.getAutoGeneratedReceiptUserId()) {
                skippedRids.add(start);
                start++;
            }
            skippedRids.removeAll(userAccountWithIds);
        }

        return skippedRids;
    }
}
